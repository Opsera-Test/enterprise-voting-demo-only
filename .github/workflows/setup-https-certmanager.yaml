# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  SETUP HTTPS - cert-manager + Let's Encrypt (RULE 17)                        â•‘
# â•‘  90% cost savings compared to ACM + Load Balancer approach                   â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ğŸ”’ Setup HTTPS (cert-manager)"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: string
        default: 'dev'
      tenant:
        description: 'Tenant/Organization name'
        required: true
        type: string
        default: 'opsera'

env:
  AWS_REGION: us-west-2
  APP_NAME: voting-app
  TENANT: ${{ inputs.tenant }}
  ENVIRONMENT: ${{ inputs.environment }}
  DOMAIN: agent.opsera.dev

permissions:
  contents: read
  id-token: write

jobs:
  setup-https:
    name: "ğŸ”’ Setup HTTPS"
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl (RULE 25)
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Generate Names
        id: names
        run: |
          case "${{ env.AWS_REGION }}" in
            us-west-2) REGION_SHORT="usw2" ;;
            us-east-1) REGION_SHORT="use1" ;;
            *) REGION_SHORT=$(echo "${{ env.AWS_REGION }}" | sed 's/-//g' | cut -c1-4) ;;
          esac
          
          if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            SPOKE_CLUSTER="${{ env.TENANT }}-${REGION_SHORT}-prod"
          else
            SPOKE_CLUSTER="${{ env.TENANT }}-${REGION_SHORT}-np"
          fi
          
          SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.${{ env.DOMAIN }}"
          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "spoke_cluster=${SPOKE_CLUSTER}" >> $GITHUB_OUTPUT
          echo "subdomain=${SUBDOMAIN}" >> $GITHUB_OUTPUT
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT

      - name: Connect to Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ steps.names.outputs.spoke_cluster }} --region ${{ env.AWS_REGION }}
          kubectl cluster-info

      - name: Checkpoint 1 - Verify cert-manager Installed
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  CHECKPOINT 1: cert-manager Installation          â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          if kubectl get namespace cert-manager &>/dev/null; then
            echo "âœ… cert-manager namespace exists"
          else
            echo "ğŸ“¦ Installing cert-manager..."
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
            
            echo "â³ Waiting for cert-manager to be ready..."
            kubectl wait --for=condition=Available deployment/cert-manager -n cert-manager --timeout=120s
            kubectl wait --for=condition=Available deployment/cert-manager-webhook -n cert-manager --timeout=120s
          fi

      - name: Checkpoint 2 - Verify ClusterIssuer
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  CHECKPOINT 2: ClusterIssuer                      â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          if kubectl get clusterissuer letsencrypt-prod &>/dev/null; then
            echo "âœ… ClusterIssuer letsencrypt-prod exists"
          else
            echo "ğŸ“ Creating ClusterIssuer..."
            cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: devops@opsera.io
              privateKeySecretRef:
                name: letsencrypt-prod-account-key
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
            echo "âœ… ClusterIssuer created"
          fi

      - name: Checkpoint 3 - Verify NGINX Ingress Controller
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  CHECKPOINT 3: NGINX Ingress Controller           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          if kubectl get namespace ingress-nginx &>/dev/null; then
            echo "âœ… NGINX Ingress Controller installed"
          else
            echo "ğŸ“¦ Installing NGINX Ingress Controller..."
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.0/deploy/static/provider/aws/deploy.yaml
            
            echo "â³ Waiting for NGINX Ingress Controller..."
            sleep 30
            kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=180s || true
          fi
          
          # Get LoadBalancer hostname
          LB_HOSTNAME=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          echo "LoadBalancer: ${LB_HOSTNAME}"

      - name: Checkpoint 4 - Wait for Certificate
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  CHECKPOINT 4: Certificate Provisioning           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          NAMESPACE="${{ steps.names.outputs.namespace }}"
          
          # Wait for certificate to be ready
          MAX_ATTEMPTS=30
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            CERT_STATUS=$(kubectl get certificate -n $NAMESPACE -o jsonpath='{.items[0].status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "NotFound")
            
            if [ "$CERT_STATUS" = "True" ]; then
              echo "âœ… Certificate is ready!"
              break
            fi
            
            echo "[$ATTEMPT/$MAX_ATTEMPTS] Certificate status: $CERT_STATUS - waiting..."
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          if [ "$CERT_STATUS" != "True" ]; then
            echo "âš ï¸ Certificate not ready after $MAX_ATTEMPTS attempts"
            kubectl get certificate -n $NAMESPACE -o yaml || true
            kubectl describe certificate -n $NAMESPACE || true
          fi

      - name: Checkpoint 5 - Verify HTTPS Endpoint (RULE 30)
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  CHECKPOINT 5: HTTPS Verification                 â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          SUBDOMAIN="${{ steps.names.outputs.subdomain }}"
          
          echo "Testing: https://${SUBDOMAIN}"
          
          # Wait for DNS propagation
          sleep 30
          
          # Test HTTPS (allow self-signed for initial test)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://${SUBDOMAIN}" -k --connect-timeout 10 || echo "000")
          
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "âœ… HTTPS endpoint accessible (HTTP ${HTTP_CODE})"
          else
            echo "âš ï¸ HTTPS endpoint returned HTTP ${HTTP_CODE}"
            echo "This may be normal if DNS is still propagating"
          fi

      - name: Summary
        run: |
          SUBDOMAIN="${{ steps.names.outputs.subdomain }}"
          
          echo "## ğŸ”’ HTTPS Setup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Vote (Frontend) | \`https://${SUBDOMAIN}/\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Result (Dashboard) | \`https://${SUBDOMAIN}/result\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Certificate" >> $GITHUB_STEP_SUMMARY
          echo "- Issuer: Let's Encrypt" >> $GITHUB_STEP_SUMMARY
          echo "- Auto-renewal: Yes (before 30 days expiry)" >> $GITHUB_STEP_SUMMARY
          echo "- Cost: $0/month (included in NGINX Ingress)" >> $GITHUB_STEP_SUMMARY
