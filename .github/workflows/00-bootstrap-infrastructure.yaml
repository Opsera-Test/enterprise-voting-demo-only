# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  BOOTSTRAP INFRASTRUCTURE - One-time setup per application                   â•‘
# â•‘  Code-to-Cloud v0.5 - Enterprise CI/CD Platform                              â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸš€ 00: Bootstrap Infrastructure"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (dev, qa, staging, prod)'
        required: true
        type: string
        default: 'dev'
      tenant:
        description: 'Tenant/Organization name'
        required: true
        type: string
        default: 'opsera'

env:
  AWS_REGION: us-west-2
  APP_NAME: voting-app
  TENANT: ${{ inputs.tenant }}
  ENVIRONMENT: ${{ inputs.environment }}

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DISCOVER INFRASTRUCTURE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  discover:
    name: "ðŸ” Discover Infrastructure"
    runs-on: ubuntu-latest
    outputs:
      hub_cluster: ${{ steps.discover.outputs.hub_cluster }}
      spoke_cluster: ${{ steps.discover.outputs.spoke_cluster }}
      region_short: ${{ steps.discover.outputs.region_short }}
      subdomain: ${{ steps.discover.outputs.subdomain }}
      
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover Clusters and Generate Names
        id: discover
        run: |
          # Generate region short code
          case "${{ env.AWS_REGION }}" in
            us-west-2) REGION_SHORT="usw2" ;;
            us-east-1) REGION_SHORT="use1" ;;
            us-west-1) REGION_SHORT="usw1" ;;
            eu-west-1) REGION_SHORT="euw1" ;;
            *) REGION_SHORT=$(echo "${{ env.AWS_REGION }}" | sed 's/-//g' | cut -c1-4) ;;
          esac
          
          # Determine environment suffix
          if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            ENV_SUFFIX="prod"
          else
            ENV_SUFFIX="np"
          fi
          
          HUB_CLUSTER="argocd-${REGION_SHORT}"
          SPOKE_CLUSTER="${{ env.TENANT }}-${REGION_SHORT}-${ENV_SUFFIX}"
          SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.agent.opsera.dev"
          
          echo "hub_cluster=${HUB_CLUSTER}" >> $GITHUB_OUTPUT
          echo "spoke_cluster=${SPOKE_CLUSTER}" >> $GITHUB_OUTPUT
          echo "region_short=${REGION_SHORT}" >> $GITHUB_OUTPUT
          echo "subdomain=${SUBDOMAIN}" >> $GITHUB_OUTPUT
          
          echo "### ðŸ” Infrastructure Discovery" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Hub Cluster | \`${HUB_CLUSTER}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Spoke Cluster | \`${SPOKE_CLUSTER}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Subdomain | \`${SUBDOMAIN}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRE-FLIGHT CHECKS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  preflight:
    name: "âœ… Pre-flight Checks"
    runs-on: ubuntu-latest
    needs: [discover]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl (RULE 25)
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: CHECK 1 - Verify Hub Cluster Exists
        run: |
          echo "Checking Hub cluster: ${{ needs.discover.outputs.hub_cluster }}"
          aws eks describe-cluster --name ${{ needs.discover.outputs.hub_cluster }} --region ${{ env.AWS_REGION }} || {
            echo "âŒ Hub cluster not found. Please ensure infrastructure is provisioned."
            exit 1
          }
          echo "âœ… Hub cluster exists"

      - name: CHECK 2 - Verify Spoke Cluster Exists
        run: |
          echo "Checking Spoke cluster: ${{ needs.discover.outputs.spoke_cluster }}"
          aws eks describe-cluster --name ${{ needs.discover.outputs.spoke_cluster }} --region ${{ env.AWS_REGION }} || {
            echo "âŒ Spoke cluster not found. Please ensure infrastructure is provisioned."
            exit 1
          }
          echo "âœ… Spoke cluster exists"

      - name: CHECK 3 - Verify Dockerfiles Exist (RULE 28)
        run: |
          for SERVICE in vote result worker; do
            if [ -f ".opsera-${{ env.APP_NAME }}/Dockerfile.${SERVICE}" ]; then
              echo "âœ… Dockerfile.${SERVICE} exists"
            else
              echo "âŒ Dockerfile.${SERVICE} not found at .opsera-${{ env.APP_NAME }}/Dockerfile.${SERVICE}"
              exit 1
            fi
          done

      - name: CHECK 4 - Verify Kustomization Exists
        run: |
          if [ -f ".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml" ]; then
            echo "âœ… Kustomization for ${{ env.ENVIRONMENT }} exists"
          else
            echo "âŒ Kustomization not found"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP ARGOCD APPLICATION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-argocd:
    name: "ðŸ”§ Setup ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [discover, preflight]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl (RULE 25)
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Update ArgoCD Application Manifest
        run: |
          APP_MANIFEST=".opsera-${{ env.APP_NAME }}/argocd/application.yaml"
          
          # Get repository URL from git remote (RULE 27)
          REPO_URL=$(git remote get-url origin)
          echo "Repository URL: ${REPO_URL}"
          
          # Update repository URL
          sed -i "s|repoURL:.*|repoURL: ${REPO_URL}|" "$APP_MANIFEST"
          
          # Update application name for environment
          sed -i "s|name: ${{ env.APP_NAME }}-.*|name: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          
          # Update environment label
          sed -i "s|environment:.*|environment: ${{ env.ENVIRONMENT }}|g" "$APP_MANIFEST"
          
          # Update source path
          sed -i "s|path: .opsera-${{ env.APP_NAME }}/k8s/overlays/.*|path: .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          
          # Update namespace
          sed -i "s|namespace: ${{ env.APP_NAME }}-.*|namespace: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}|" "$APP_MANIFEST"
          
          # Update destination cluster name
          sed -i "s|name: .*-np|name: ${{ needs.discover.outputs.spoke_cluster }}|" "$APP_MANIFEST"
          sed -i "s|name: .*-prod|name: ${{ needs.discover.outputs.spoke_cluster }}|" "$APP_MANIFEST"
          
          echo "Updated ArgoCD manifest:"
          cat "$APP_MANIFEST"

      - name: Update Ingress Subdomain (RULE 29)
        run: |
          SUBDOMAIN="${{ needs.discover.outputs.subdomain }}"
          
          # Update base ingress
          sed -i "s/PLACEHOLDER_SUBDOMAIN/${SUBDOMAIN}/g" ".opsera-${{ env.APP_NAME }}/k8s/base/ingress.yaml"
          
          # Update overlay patch
          PATCH_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENVIRONMENT }}/patch-ingress.yaml"
          if [ -f "$PATCH_FILE" ]; then
            sed -i "s/PLACEHOLDER_SUBDOMAIN/${SUBDOMAIN}/g" "$PATCH_FILE"
            echo "Updated ingress subdomain to: ${SUBDOMAIN}"
          fi

      - name: Commit Changes (RULE 8)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main || true
          git add .
          git diff --staged --quiet || git commit -m "chore: configure ${{ env.APP_NAME }} for ${{ env.ENVIRONMENT }} [skip ci]"
          git push origin main || echo "No changes to push"

      - name: Connect to Hub and Apply ArgoCD Application
        run: |
          aws eks update-kubeconfig --name ${{ needs.discover.outputs.hub_cluster }} --region ${{ env.AWS_REGION }}
          
          # Create ArgoCD repo secret if not exists
          REPO_URL=$(git remote get-url origin)
          SECRET_NAME="repo-$(echo ${{ github.repository }} | tr '/' '-')"
          
          kubectl get secret "${SECRET_NAME}" -n argocd 2>/dev/null || \
          kubectl create secret generic "${SECRET_NAME}" \
            -n argocd \
            --from-literal=url="${REPO_URL}" \
            --from-literal=password="${{ secrets.GH_PAT }}" \
            --from-literal=username=git \
            --from-literal=type=git
          
          kubectl label secret "${SECRET_NAME}" \
            -n argocd argocd.argoproj.io/secret-type=repository --overwrite || true
          
          # Apply ArgoCD Application
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/application.yaml
          
          echo "### ðŸŽ¯ ArgoCD Application Created" >> $GITHUB_STEP_SUMMARY
          echo "Application: \`${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY

      - name: Verify ArgoCD Application Created (RULE 26)
        run: |
          sleep 10
          kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd
          
          SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          
          if [ "$SYNC_STATUS" = "Unknown" ]; then
            echo "âš ï¸ Sync status is Unknown - this may indicate a configuration issue"
            echo "Checking application details..."
            kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o yaml
          fi
          
          echo "### ArgoCD Application Status" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Application | \`${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Sync Status | \`${SYNC_STATUS}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“‹ Bootstrap Summary"
    runs-on: ubuntu-latest
    needs: [discover, preflight, setup-argocd]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "## ðŸš€ Bootstrap Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Application | \`${{ env.APP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ env.ENVIRONMENT }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Hub Cluster | \`${{ needs.discover.outputs.hub_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Spoke Cluster | \`${{ needs.discover.outputs.spoke_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | \`https://${{ needs.discover.outputs.subdomain }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Run CI/CD workflow: \`gh workflow run 20-ci-build-push.yaml\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Run HTTPS setup: \`gh workflow run setup-https-certmanager.yaml\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify deployment at: https://${{ needs.discover.outputs.subdomain }}" >> $GITHUB_STEP_SUMMARY
